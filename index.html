<!doctype html>
<html>
  <head>
    <title>Dancer in the Dark</title>
    <link rel="stylesheet" type="text/css" href="css/reset.css" />
    <link rel="stylesheet" type="text/css" href="css/base.css" />
    <link rel="stylesheet" type="text/css" href="css/constructions.css" />
    <link rel="stylesheet" type="text/css" href="css/decorations.css" />
    <link rel="stylesheet" type="text/css" href="css/humans.css" />
    <style></style>
  </head>
  <body>
    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="js/simpleCookie.js"></script>
    <script>
      let isSpriteMode = getCookie('spriteMode') === 'true'
      // run this from the command line to turn on sprites
      function setSpriteMode (spriteMode = 'true') {
        setCookie('spriteMode', spriteMode, 1)
        isSpriteMode = spriteMode === 'true'
      }

      $(function () {

        const socket = io()

        const KEY = {
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          SPACEBAR: 32,
          F: 70, // (F)ire
          C: 67 // (C)ancel
        }

        const SINGLE_KEYCODES = [KEY.LEFT, KEY.UP, KEY.RIGHT, KEY.DOWN, KEY.SPACEBAR, KEY.C]
        // Require two keys to be pressed
        const COMBO_KEYCODES = [KEY.F]

        const ALLOWED_KEYCODES = SINGLE_KEYCODES.concat(COMBO_KEYCODES)

        const $playerListContainer = $('#player-list-container')
        const $messageContainer = $('#message-container')
        const $rulesContainer = $('#rules-container')
        const $mapContainer = $('#map-container')
        const $movesRemaining = $('#moves-remaining')
        const $movementTimeRemaining = $('#movement-time-remaining')

        function isAllowedKey (keyCode) {
          return ALLOWED_KEYCODES.includes(keyCode)
        }

        function isSingleKey (keyCode) {
          return SINGLE_KEYCODES.includes(keyCode)
        }

        function isComboKey (keyCode) {
          return COMBO_KEYCODES.includes(keyCode)
        }

        let previousKey = null // only supports combos of 2 keys

        $('body').on('keydown', (key) => {
          const keyCode = key.keyCode
          if (isAllowedKey(keyCode)) {
            if (isSingleKey(keyCode) && previousKey === null) { // move/wait
              emitSingleKey(keyCode)
            } else if (keyCode === KEY.C) { // cancel
              if (previousKey === KEY.F) {
                addMessage({payload: 'You curse your indecisiveness.', type: 'failure'})
              }
              previousKey = null
            } else if (isComboKey(keyCode)) { // start action
              previousKey = keyCode
              if (keyCode === KEY.F) {
                addMessage({payload: 'You notch an arrow. Which direction do you shoot?', type: 'event'})
              }
            } else if (previousKey !== null && isSingleKey(keyCode)) { // finish action
              emitComboKey([previousKey, keyCode])
              previousKey = null
            }

            // Prevents page from moving around from arrow keys and spacebar
            return false
          }
        })

        function emitSingleKey (keyCode) {
          socket.emit('client single key', keyCode);
        }

        function emitComboKey (keyCodes) {
          socket.emit('client combo keys', keyCodes);
        }

        socket.on('message', message => {
          addMessage(message)
        })

        function addMessage(message) {
          // TODO: break out into shared file
          const allowedTypes = ['general', 'success', 'failure', 'event']
          let typeClass = allowedTypes.includes(message.type) ? message.type : 'general'
          $messageContainer.find('ul').append(`<li><span class="${typeClass}">${message.payload}</span></li>`)

          const messageLimit = 20
          if ($messageContainer.find('li').length > messageLimit) {
            $messageContainer.find('li').first().remove()
          }
          // TODO: animate a flash when a new message is added
          // TODO: scroll only if currently at the bottom?
          $messageContainer.animate({
            scrollTop: $messageContainer.prop('scrollHeight') - $messageContainer.height()
          }, 100)
        }

        socket.on('map', map => {
          $mapContainer.html(buildMap(map))
        })

        socket.on('players', players => {
          // TODO: Need a better way of handling how players are drawn
          // We are currently updating player position despite them needing to be invisible
          $mapContainer.find('.player').remove()

          players.forEach((player, playerId) => {
            drawPlayer(playerId, player.x, player.y)
          })
        })

        // TODO: make this into a class, and give it an update method
        let playerId = null
        let turn = null
        let playersPublicInfo = []

        socket.on('playerId', passedPlayerId => {
          playerId = passedPlayerId
        })

        socket.on('turn', passedTurn => {
          turn = passedTurn
          updatePlayerNames()
        })

        socket.on('movesRemaining', movesRemaining => {
          // TODO: this would be a good place to pass the countdown timer and set it locally.
          // TODO: clean this up when you feel like it
          $movesRemaining.html(movesRemaining)
        })

        socket.on('movementTimer', movementTimerSecondsRemaining => {
          // Set the movement timer, and show whose turn it is for
          $movementTimeRemaining.html(movementTimerSecondsRemaining)
        })

        const timerTick = () => {
          let remainingSeconds = parseInt($movementTimeRemaining.html())
          if (remainingSeconds > 0) {
            $movementTimeRemaining.html(remainingSeconds - 1)
          }
        }
        setInterval(timerTick, 1000)

        socket.on('playersPublicInfo', passedPlayerPublicInfo => {
          // TODO: change this to include index as well as name??
          playersPublicInfo = passedPlayerPublicInfo
          updatePlayerNames()
        })

        function updatePlayerNames () {
          if (playersPublicInfo === [] || turn === null || playerId === null) {
            return
          }
          // TODO: do we need to add a templating engine now? lol.
          // yeeee, so much to do. Just focus on this and then switch to using Vue or React
          let builtList = ''
          let classes = []
          let isYou = false
          let isTurn = false
          playersPublicInfo.forEach((player, index) => {
            classes = []
            isYou = index === playersPublicInfo.map(ppi => ppi.socketId).indexOf(playerId)
            isTurn = index === turn
            if (isYou) {
              classes.push('you')
            }
            if (isTurn) {
              classes.push('current-turn')
            }
            builtList += `<li class="${classes.join(' ')}">${isTurn ? '→' : ''}${isYou ? '(YOU) ' : ''}${player.name}</li><!--${player.id}-->`
          })
          // TODO: better styles for this
          $playerListContainer.find('ul').html(builtList)
        }

        function drawPlayer (playerId, x, y) {
          // TODO: classes, IDs, etc
          // TODO: less hacky garbage
          // const playerClass = `human_${playerId + 1}`
          if (playerId === 0) {
            playerClass = 'player1'
          } else if (playerId === 1) {
            playerClass = 'player2'
          }

          $mapContainer.find(`.row:eq(${y})`).find(`.tile:eq(${x})`).append(`<div class="player ${playerClass}"></div>`)
        }

        function buildMap (map) {
          let builtMap = ''
          const bgMap = map.seenBgMap
          const itemMap = map.seenItemMap
          const fogOfWarMap = map.fogOfWarMap

          for (let y = 0; y < bgMap.length; y++) {
            builtMap += '<div class="row">'
            for (let x = 0; x < bgMap[0].length; x++) {
              // TODO: how should fow be displayed above other content?
              builtMap += `<div class="tile ${tileBgClass(bgMap[y][x])} ">${fogOfWarMap[y][x] ? '<div class="fog-of-war"></div>' : ''}${items(itemMap[y][x])}</div>`
            }
            builtMap += '</div>'
          }
          return builtMap
        }

        function items (tileContent) {
          if (tileContent === null) {
            return ''
          }
          // TODO: not sure what direction I am going with this yet. We want the items to be stacked and visible. However, we want the exit to be very clearly visible.
          // For now, I will focus on the following:
          // 1) display the characters
          // 2) change the characters to squares and create a way to stack them or split it up
          // so up to 4 are visible at once
          // Additionally, a "look" system may be required for seeing items on the square
          const itemString = tileContent.map(item => {
            return item._type
          }).join('')
          return itemString
        }

        // TODO: probably want to break this out into another file at some point in time. This will get large
        function tileBgClass (tileCode) {
          // For developing where we don't want the sprites shown, tee hee
          if (!isSpriteMode) {
            if (tileCode === ' ') {
              return 'floor'
            } else if (tileCode === '0') {
              return 'unknown'
            } else if ('─│└┌┐┘├┤┬┴┼?.'.includes(tileCode)) {
              return 'wall'
            }
          } else {
            if (tileCode === ' ') {
              return 'decoration_1' // floor
            } else if (tileCode === '0') {
              return 'unknown'
            }

            return 'basic_' + ('─│└┌┐┘├┤┬┴┼?.'.indexOf(tileCode) + 1)
          }
        }
      })
    </script>
    <style>
    #page {
      background: #fff;
      width: 100%;
      height: 100%;
    }

    /* work version */
    .tile {
      background-color: #efefef;
    }

    .floor {
      background-color: #ddd;
    }

    .wall {
      background-color: #bbb;
    }

    .player {
      position: absolute;
      top: 0;
      left: 0;
      height: 32px;
      width: 32px;
      z-index: 1;
    }

    .player1 {
      background-color: #ebe;
    }

    .player2 {
      background-color: #eeb;
    }

    .tile.treasure {
      background-color: #fb6;
    }

    .tile.trap {
      background-color: #ffd1d1;
    }

    .tile.unknown {
      background-color: #333;
    }

    .fog-of-war {
      position: absolute;
      top: 0;
      left: 0;
      height: 32px;
      width: 32px;
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 10;
    }

    .player-list {
      color: #ccc;
    }

    /* TODO:flexbox or grid */
    #player-list-container {
      min-width: 160px;
      width: 20%;
      float: left;
      border: 1px solid #111;
      /* DRY */
      height: 100px;
      background-color: #fafbfc;
      font-size: 16px;
      box-shadow: inset 0 1px 2px rgba(27,31,35,0.075);
    }

    .player-list .you {
      color: #000;
    }

    .player-list .current-turn {
      font-weight: bold;
    }

    #message-container {
      overflow-y: scroll;
      float: left;
      width: 40%;
      height: 100px;
      background-color: #fafbfc;
      font-size: 16px;
      box-shadow: inset 0 1px 2px rgba(27,31,35,0.075);
    }

    #message-container ul {
      list-style: none;
      padding: 0 0 0 10px;
      margin: 0;
    }

    #message-container span.general {
      color: #111;
    }

    #message-container span.success {
      color: #24af4c;
    }

    #message-container span.failure {
      color: #d84831;
    }

    #message-container span.event {
      color: #d8a931;
    }

    #moves-container {
      float: left;
      min-width: 160px;
      width: 20%;
      height: 100px;
      background-color: #fafbfc;
      font-size: 16px;
      box-shadow: inset 0 1px 2px rgba(27,31,35,0.075);
    }

    #rules-container {
      overflow-y: scroll;
      float: left;
      min-width: 160px;
      width: 20%;
      height: 100px;
      background-color: #fafbfc;
      font-size: 16px;
      box-shadow: inset 0 1px 2px rgba(27,31,35,0.075);
    }
    </style>
    <div id="page">
      <header>
        <div id="player-list-container">
          <ul class="player-list">
          </ul>
        </div>
        <div id="message-container">
          <ul>
          </ul>
        </div>
        <div id="moves-container">
          <ul>
            <li>Moves remaining: <span id="moves-remaining"></span></li>
            <li>Time remaining: <span id="movement-time-remaining"></span>s</li>
          </ul>
        </div>
        <div id="rules-container">
          <ul>
            <li>3 moves per turn</li>
            <li>Arrow keys move</li>
            <li>Spacebar waits</li>
            <li>F and then arrow key (F)ires an arrow in that direction</li>
            <li>C cancels firing an arrow</li>
          </ul>
        </div>
      </header>
      <div id="map-container" class="map-container">
      </div>
    </div>
  </body>
</html>
